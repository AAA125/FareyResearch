<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/processing.js/1.6.6/processing.min.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="myCanvas"></canvas>
  <script type="text/processing" data-processing-target="myCanvas">
    float r;
    float zoom = 1.0;
    float translateX = 0;
    float translateY = 0;
    float centerX, centerY;

    void setup() {
      size(window.innerWidth, window.innerHeight);
      centerX = width / 2;
      centerY = height / 2;
      r = min(width, height) * 0.4; // Set radius to 40% of the smaller dimension
      background(255);
    }

    void draw() {
      background(255);
      pushMatrix();
      translate(translateX, translateY);
      scale(zoom);
      
      // Draw the main circle
      noFill();
      stroke(0);
      ellipse(centerX, centerY, r * 2, r * 2);
      
      
      FareyPoints(1);
        
      
      popMatrix();
    }

    void mouseWheel(MouseEvent event) {
      float e = event.getAmount();
      float newZoom = zoom * ((e > 0) ? 0.95 : 1.05);
      if (newZoom > 0.1 && newZoom < 10) {  // Limit zoom range
        zoom = newZoom;
        translateX -= (mouseX - translateX) * (1 - 1/zoom);
        translateY -= (mouseY - translateY) * (1 - 1/zoom);
      }
    }

    void mouseDragged() {
      translateX += mouseX - pmouseX;
      translateY += mouseY - pmouseY;
    }

    void FareyPoints(int n) {
      ArrayList<Float> P = Farey(n);
      
      // Draw the points on the circle
      for (int i = 0; i < P.size(); i++) {
        float x = centerX + r*cos(P.get(i));
        float y = centerY - r*sin(P.get(i));
        fill(#17E6FF, 127);
        noStroke();
        ellipse(x, y, 10, 10);
      }
      
      // Calculate and draw intersections and new circles
      for (int i = 0; i < P.size(); i++) {
        int nextIndex = (i + 1) % P.size();
        float angle1 = P.get(i);
        float angle2 = P.get(nextIndex);
        
        float[] intersection = calculateIntersection(angle1, angle2);
        
        if (!Float.isNaN(intersection[0]) && !Float.isNaN(intersection[1])) {
          // Draw intersection point
          fill(255, 0, 0);
          noStroke();
          ellipse(intersection[0], intersection[1], 10, 10);
          
          // Calculate distance to one of the original Farey circle points
          float x1 = centerX + r * cos(angle1);
          float y1 = centerY - r * sin(angle1);
          float distance = dist(intersection[0], intersection[1], x1, y1);
          
          // Draw new circle
          noFill();
          stroke(0, 255, 0);
          strokeWeight(2);
          ellipse(intersection[0], intersection[1], distance * 2, distance * 2);
        }
      }
    }

    float[] calculateIntersection(float angle1, float angle2) {
      // Calculate points on the circle
      float x1 = centerX + r * cos(angle1);
      float y1 = centerY - r * sin(angle1);
      float x2 = centerX + r * cos(angle2);
      float y2 = centerY - r * sin(angle2);
      
      // Calculate tangent slopes
      float m1 = cos(angle1) / sin(angle1);
      float m2 = cos(angle2) / sin(angle2);
      
      // Handle vertical tangents
      if (abs(sin(angle1)) < 1e-6 || abs(sin(angle2)) < 1e-6) {
        float x, y;
        if (abs(sin(angle1)) < 1e-6) {
          x = x1;
          y = m2 * (x - x2) + y2;
        } else {
          x = x2;
          y = m1 * (x - x1) + y1;
        }
        return new float[] {x, y};
      }
      
      // Calculate intersection
      float x = (y2 - y1 + m1*x1 - m2*x2) / (m1 - m2);
      float y = m1 * (x - x1) + y1;
      
      return new float[] {x, y};
    }

    ArrayList<Float> Farey(int n) {
      ArrayList<Float> equi = new ArrayList<Float>();
      if (n == 0) {
        for (int i = 0; i < 4; i++) {
          equi.add(i * PI/2);
        }
      } else {
        ArrayList<Float> prevFarey = Farey(n-1);
        for (int j = 0; j < prevFarey.size() - 1; j++) {
          equi.add(prevFarey.get(j));
          equi.add((prevFarey.get(j) + prevFarey.get(j+1)) / 2);
        }
        equi.add(prevFarey.get(prevFarey.size()-1));
        equi.add((prevFarey.get(prevFarey.size()-1) + 2*PI) / 2);
      }
      return equi;
    }
  </script>
</body>
</html>
