<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farey Diagram</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/processing.js/1.6.6/processing.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <script type="text/processing" data-processing-target="myCanvas">
        float r;
        float zoom = 1.0;
        float translateX = 0;
        float translateY = 0;
        float centerX, centerY;

        void setup() {
            size(window.innerWidth, window.innerHeight);
            centerX = width / 2;
            centerY = height / 2;
            r = min(width, height) * 0.4;
            frameRate(60);
        }

        void draw() {
            background(255);
            pushMatrix();
            translate(translateX + width / 2, translateY + height / 2);
            scale(zoom);
            translate(-width / 2, -height / 2);

            // Draw the main circle
            noFill();
            stroke(0);
            ellipse(centerX, centerY, r * 2, r * 2);

            // Call FloatPoints for k from 0 to 9
            for (int k = 0; k < 10; k++) {
                FloatPoints(k);
            }

            popMatrix();
        }

        void mouseWheel(MouseEvent event) {
            float e = event.getCount();
            float newZoom = zoom * (1 - e * 0.05);
            if (newZoom > 0.1 && newZoom < 10) {
                float mouseXScaled = (mouseX - translateX) / zoom;
                float mouseYScaled = (mouseY - translateY) / zoom;
                zoom = newZoom;
                translateX -= mouseXScaled * (zoom - newZoom);
                translateY -= mouseYScaled * (zoom - newZoom);
            }
        }

        void mouseDragged() {
            translateX += mouseX - pmouseX;
            translateY += mouseY - pmouseY;
        }

        void FloatPoints(int n) {
            float[] P = Farey(n);

            // Draw the points on the circle
            for (int i = 0; i < P.length; i++) {
                float x = centerX + r * cos(P[i]);
                float y = centerY - r * sin(P[i]);
                fill(#17E6FF, 127);
                noStroke();
                ellipse(x, y, 10, 10);
            }
        }

        float[] Farey(int n) {
            float[] equi;
            if (n == 0) {
                equi = new float[4];
                equi[0] = 0;
                equi[1] = PI / 2;
                equi[2] = PI;
                equi[3] = 3 * PI / 2;
            } else {
                float[] prevFarey = Farey(n - 1);
                equi = new float[prevFarey.length * 2];
                for (int j = 0; j < prevFarey.length; j++) {
                    equi[2 * j] = prevFarey[j];
                    if (j < prevFarey.length - 1) {
                        equi[2 * j + 1] = (prevFarey[j] + prevFarey[j + 1]) / 2;
                    } else {
                        equi[2 * j + 1] = (prevFarey[j] + 2 * PI) / 2;
                    }
                }
            }
            return equi;
        }
    </script>
</body>
</html>
